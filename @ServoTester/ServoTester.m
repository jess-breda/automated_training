%% ServoTester.m
% 
% Written by Jess Breda October 2022
% 
% Used to test & calibrate servos driven via
% Bpod BNC out for port door prototype.
% 
% 
% 

function [obj] = ServoTester(varargin)

obj = class(struct, mfilename);

%---------------------------------------------------------------
%   BEGIN SECTION COMMON TO ALL PROTOCOLS, DO NOT MODIFY
%---------------------------------------------------------------

% If creating an empty object, return without further ado:
if nargin==0 || (nargin==1 && ischar(varargin{1}) && strcmp(varargin{1}, 'empty')), 
   return; 
end;
 
if isa(varargin{1}, mfilename), % If first arg is an object of this class itself, we are 
                                % Most likely responding to a callback from  
                                % a SoloParamHandle defined in this mfile.
  if length(varargin) < 2 || ~ischar(varargin{2}), 
    error(['If called with a "%s" object as first arg, a second arg, a ' ...
      'string specifying the action, is required\n']);
  else action = varargin{2}; varargin = varargin(3:end); %#ok<NASGU>
  end;
else % Ok, regular call with first param being the action string.
       action = varargin{1}; varargin = varargin(2:end); %#ok<NASGU>
end;
if ~ischar(action), error('The action parameter must be a string'); end;

GetSoloFunctionArgs(obj);

%---------------------------------------------------------------
%   END OF SECTION COMMON TO ALL PROTOCOLS, MODIFY AFTER THIS LINE
%---------------------------------------------------------------

switch action

    %---------------------------------------------------------------%
    %          INIT                                                 %
    %---------------------------------------------------------------%
    case 'init'

        % Make default figure non-saveable to prevent overwrite
        SoloParamHandle(obj, 'myfig', 'saveable', 0); myfig.value = double(figure);

        % Set title, starting GUI locations & dimensions
        set(value(myfig), 'Name', mfilename, 'Tag', mfilename, ...
            'closerequestfcn', 'dispatcher(''close_protocol'')', 'MenuBar', 'none');
        x = 10; y = 10;
        w = 150; h = 30; x_offset = 165; n_cols = 4; n_rows = 18;

        % specify GUI position & size [x, y, width, height]
        set(value(myfig), 'Position', [700 50 (x_offset*n_cols) ((n_rows*1.3) * h)]);
        
        %%% RIGHT CLOSE VARIABLES %%%
        %%%---
        % Number of wave loops for final close
        NumeditParam(obj, 'r_close_n_loops', 5, x, y,'labelfraction',0.5,...
        'TooltipString', sprintf(['\nNumber of loops of the wave (i.e. \nnumber ',...
                        'of pulses that will be sent to servo)']),...
        'label', 'N loops', 'position', [x y w 30]);
        % Close Pause Time
        NumeditParam(obj, 'r_close_pause_time_s', 0.75, x, y,'labelfraction',0.5,...
        'TooltipString', sprintf(['\nTime in seconds to pause in close 1 and 2 \nsates ',...
                        'that occur between the close servo waves triggers)']),...
        'label', 'pause time [ms]', 'position', [x+x_offset y w 30]);
        % Duty cycle (high/low * 100) for final close
        DispParam(obj, 'r_close_duty_cycle', 7.5, x, y, 'labelfraction', 0.7,...
        'TooltipString', sprintf(['\ngiven on, off time, the percent of time in \nloop ',...
                                  'spent with the wave hi/pulse on']),...
        'label', 'duty cycle [%]', 'position', [x+(2*x_offset) y w 30]);
        % Pulse rate (n highs/second) for final close
        DispParam(obj, 'r_close_pulse_rate', 50, x, y, 'labelfraction', 0.7,...
        'TooltipString', sprintf(['\ngiven on and off time, how many pulses \nper ',...
                         'second (Hz). Servo expects btwn 20-200 Hz ']),...
        'label', 'pulse rate [Hz]', 'position', [x+(3*x_offset) y w 30]); next_row(y,1.75);;;
        %%%---- 
        % Off/lo time in single pulse (1 loop) for final close
        NumeditParam(obj, 'r_close_off_time_ms', 18.5, x, y,'labelfraction',0.5,...
        'TooltipString', sprintf(['\noff time in miliseconds of a single TTL \npulse ',...
                        'in the servo wave that will be repeated for nloops']),...
        'label', 'OFF time [ms]', 'position', [x y w 30]);
        % Close wave 2 on time
        NumeditParam(obj, 'r_close_2_on_time_ms', 1.6, x, y,'labelfraction',0.5,...
        'TooltipString', sprintf(['\non time of second servo wave that will \nmove ',...
                        'the servo slightly further indicate close is happening']),...
        'label', 'close 2 on time [ms]', 'position', [x+x_offset y w 30]);
        % Total off time for final close
        DispParam(obj, 'r_close_total_off_time_ms', 92.5, x, y, 'labelfraction', 0.7,...
        'TooltipString', sprintf(['\ngiven off time and n loops how \nlong ',...
                         'the wave is low in ms']),...
        'label', 'total off time [ms]', 'position', [x+(2*x_offset) y w 30]);
        % Total duration of all loops (on time + off time) * nloops for final close
        DispParam(obj, 'r_close_loops_duration_ms', 100, x, y, 'labelfraction', 0.7,...
        'TooltipString', sprintf(['\ngiven on, off and n loops, how long the \nservop ',...
                         'wave TTL signal will last in seconds']),...
        'label', 'loops dur [ms]', 'position', [x+(3*x_offset) y w 30]); next_row(y,1.75);;;
        %%%---
        % On/hi time in a single loop (this is the final close on time)
        NumeditParam(obj,'r_close_on_time_ms',1.5,x, y, 'labelfraction',0.5,...
        'TooltipString', sprintf(['\non time in miliseconds of a single TTL \npulse ',...
                        ' in the servo wave that will be repeated for \nnloops. ',...
                        ' this is the final close time/destination and close \n1',....
                        ' and close 2 time are the first and second smaller \nsteps',...
                        ' before this triggers to ensure animal has warning of \nclose',...
                        ' Generally, 1.5 is 90 deg, < 1.5 is 0 deg, > 1.5 is 180 deg']),...
        'label','ON time [ms]', 'position', [x y w 30]);
        % Close wave 1 on time
        NumeditParam(obj, 'r_close_1_on_time_ms', 1.8, x, y,'labelfraction',0.5,...
        'TooltipString', sprintf(['\non time of first servo wave that will \nslightly ',...
                        'move the to indicate close is happening']),...
        'label', 'close 1 on time [ms]', 'position', [x+x_offset y w 30]);         
        % Total off time (used for 1st, 2nd and 3rd (final) wave close)
        DispParam(obj, 'r_close_total_on_time_ms', 7.5, x, y, 'labelfraction', 0.7,...
        'TooltipString', sprintf(['\ngiven on time and n loops how \nlong ',...
                         'the wave is hi in ms']),...
        'label', 'total on time [ms]', 'position', [x+(2*x_offset) y w 30]);
        % Duration of 1 loop (on time + off time) for final close
        DispParam(obj, 'r_close_loop_duration_ms', 20, x, y, 'labelfraction', 0.7,...
        'TooltipString', sprintf(['\nthe length of a single loop as defined \nby ',...
                         'on time + off time. Multipled by n loops & converted \nto ',...
                         'seconds gets you the wave duration']),...
        'label', 'loop dur [ms]', 'position', [x+(3*x_offset) y w 30]); next_row(y,1.75);;;
        %%%---
        SubheaderParam(obj,'lab1', 'Parameters',x,y,'position', [x y (2*w)-10 30]);
        SubheaderParam(obj,'lab3', 'Summary', x, y, 'position', [x+(2*x_offset) y x_offset 30]);
        PushbuttonParam(obj, 'update_r_close_summary', x, y, 'position', [x+(3*x_offset) y w-10 30],...
            'label', 'update', 'TooltipString', 'Given parameters, update servo close summary info.');
        set_callback(update_r_close_summary, {mfilename, 'calculate_right_close_summary'});next_row (y,1.5)
                SubheaderParam(obj,'lab1', 'RIGHT CLOSE- Trigger via  R or C poke OUT on Bpod Console',...
                x,y,'position', [x+30 y w*n_cols 30]);next_row(y,1.75);;;
        
        %%% RIGHT OPEN VARIABLES %%%
        %%%---
        % Number of wave loops
        NumeditParam(obj, 'r_open_n_loops', 5, x, y,'labelfraction',0.5,...
        'TooltipString', sprintf(['\nNumber of loops of the wave (i.e. \nnumber ',...
                        'of pulses that will be sent to servo)']),...
        'label', 'N loops', 'position', [x y w 30]);
        % Duty cycle (high/low * 100)
        DispParam(obj, 'r_open_duty_cycle', 9.5, x, y, 'labelfraction', 0.7,...
        'TooltipString', sprintf(['\ngiven on, off time, the percent of time in \nloop ',...
                                  'spent with the wave hi/pulse on']),...
        'label', 'duty cycle [%]', 'position', [x+(2*x_offset) y w 30]);
        % Pulse rate (n highs/second )
        DispParam(obj, 'r_open_pulse_rate', 50, x, y, 'labelfraction', 0.7,...
        'TooltipString', sprintf(['\ngiven on and off time, how many pulses \nper ',...
                         'second (Hz). Servo expects btwn 20-200 Hz ']),...
        'label', 'pulse rate [Hz]', 'position', [x+(3*x_offset) y w 30]); next_row(y,1.75);;;
        %%%---
        % Off/lo time in single pulse (1 loop)
        NumeditParam(obj, 'r_open_off_time_ms', 18.1, x, y,'labelfraction',0.5,...
        'TooltipString', sprintf(['\noff time in miliseconds of a single TTL \npulse ',...
                        'in the servo wave that will be repeated for nloops']),...
        'label', 'OFF time [ms]', 'position', [x y w 30]);
        % Total off time
        DispParam(obj, 'r_open_total_off_time_ms', 90.5, x, y, 'labelfraction', 0.7,...
        'TooltipString', sprintf(['\ngiven off time and n loops how \nlong ',...
                         'the wave is low in ms']),...
        'label', 'total off time [ms]', 'position', [x+(2*x_offset) y w 30]);
        % Total duration of all loops (on time + off time) * nloops
        DispParam(obj, 'r_open_loops_duration_ms', 100, x, y, 'labelfraction', 0.7,...
        'TooltipString', sprintf(['\ngiven on, off and n loops, how long the \nservop ',...
                         'wave TTL signal will last in seconds']),...
        'label', 'loops dur [ms]', 'position', [x+(3*x_offset) y w 30]); next_row(y,1.75);;;
        %%%---
        % On/hi time in a single loop
        NumeditParam(obj,'r_open_on_time_ms',1.9,x, y, 'labelfraction',0.5,...
        'TooltipString', sprintf(['\non time in miliseconds of a single TTL \npulse ',...
                        'in the servo wave that will be repeated for \nnloops. '...,
                        ' Generally, 1.5 is 90 deg, < 1.5 is 0 deg, > 1.5 is 180 deg']),...
        'label','ON time [ms]', 'position', [x y w 30]);
        % Total off time
        DispParam(obj, 'r_open_total_on_time_ms', 9.5, x, y, 'labelfraction', 0.7,...
        'TooltipString', sprintf(['\ngiven on time and n loops how \nlong ',...
                         'the wave is hi in ms']),...
        'label', 'total on time [ms]', 'position', [x+(2*x_offset) y w 30]);
        % Duration of 1 loop (on time + off time)
        DispParam(obj, 'r_open_loop_duration_ms', 20, x, y, 'labelfraction', 0.7,...
        'TooltipString', sprintf(['\nthe length of a single loop as defined \nby ',...
                         'on time + off time. Multipled by n loops & converted \nto ',...
                         'seconds gets you the wave duration']),...
        'label', 'loop dur [ms]', 'position', [x+(3*x_offset) y w 30]); next_row(y,1.75);;;
        %%%---
        SubheaderParam(obj,'lab1', 'Parameters',x,y,'position', [x y (2*w)-10 30]);
        SubheaderParam(obj,'lab3', 'Summary', x, y, 'position', [x+(2*x_offset) y x_offset 30]);
        PushbuttonParam(obj, 'update_r_open_summary', x, y, 'position', [x+(3*x_offset) y w-10 30],...
            'label', 'update', 'TooltipString', 'Given parameters, update servo open summary info.');
        set_callback(update_r_open_summary, {mfilename, 'calculate_right_open_summary'});next_row (y,1.5)
                SubheaderParam(obj,'lab1', 'RIGHT OPEN- Trigger via R or C poke IN on Bpod Console',...
            x,y,'position', [x+30 y w*n_cols 30]); next_row(y,1.75);;;
        
        %%% LEFT CLOSE VARIABLES %%%
        %%%---
        % Number of wave loops for final close
        NumeditParam(obj, 'l_close_n_loops', 5, x, y,'labelfraction',0.5,...
        'TooltipString', sprintf(['\nNumber of loops of the wave (i.e. \nnumber ',...
                        'of pulses that will be sent to servo)']),...
        'label', 'N loops', 'position', [x y w 30]);
        % Close Pause Time
        NumeditParam(obj, 'l_close_pause_time_s', 0.75, x, y,'labelfraction',0.5,...
        'TooltipString', sprintf(['\nTime in seconds to pause in close 1 and 2 \nsates ',...
                        'that occur between the close servo waves triggers)']),...
        'label', 'pause time [ms]', 'position', [x+x_offset y w 30]);
        % Duty cycle (high/low * 100) for final close
        DispParam(obj, 'l_close_duty_cycle', 7.5, x, y, 'labelfraction', 0.7,...
        'TooltipString', sprintf(['\ngiven on, off time, the percent of time in \nloop ',...
                                  'spent with the wave hi/pulse on']),...
        'label', 'duty cycle [%]', 'position', [x+(2*x_offset) y w 30]);
        % Pulse rate (n highs/second) for final close
        DispParam(obj, 'l_close_pulse_rate', 50, x, y, 'labelfraction', 0.7,...
        'TooltipString', sprintf(['\ngiven on and off time, how many pulses \nper ',...
                         'second (Hz). Servo expects btwn 20-200 Hz ']),...
        'label', 'pulse rate [Hz]', 'position', [x+(3*x_offset) y w 30]); next_row(y,1.75);;;
        %%%---- 
        % Off/lo time in single pulse (1 loop) for final close
        NumeditParam(obj, 'l_close_off_time_ms', 18.5, x, y,'labelfraction',0.5,...
        'TooltipString', sprintf(['\noff time in miliseconds of a single TTL \npulse ',...
                        'in the servo wave that will be repeated for nloops']),...
        'label', 'OFF time [ms]', 'position', [x y w 30]);
        % Close wave 2 on time
        NumeditParam(obj, 'l_close_2_on_time_ms', 1.4, x, y,'labelfraction',0.5,...
        'TooltipString', sprintf(['\non time of second servo wave that will \nmove ',...
                        'the servo slightly further indicate close is happening']),...
        'label', 'close 2 on time [ms]', 'position', [x+x_offset y w 30]);
        % Total off time for final close
        DispParam(obj, 'l_close_total_off_time_ms', 92.5, x, y, 'labelfraction', 0.7,...
        'TooltipString', sprintf(['\ngiven off time and n loops how \nlong ',...
                         'the wave is low in ms']),...
        'label', 'total off time [ms]', 'position', [x+(2*x_offset) y w 30]);
        % Total duration of all loops (on time + off time) * nloops for final close
        DispParam(obj, 'l_close_loops_duration_ms', 100, x, y, 'labelfraction', 0.7,...
        'TooltipString', sprintf(['\ngiven on, off and n loops, how long the \nservop ',...
                         'wave TTL signal will last in seconds']),...
        'label', 'loops dur [ms]', 'position', [x+(3*x_offset) y w 30]); next_row(y,1.75);;;
        %%%---
        % On/hi time in a single loop (this is the final close on time)
        NumeditParam(obj,'l_close_on_time_ms',1.5,x, y, 'labelfraction',0.5,...
        'TooltipString', sprintf(['\non time in miliseconds of a single TTL \npulse ',...
                        ' in the servo wave that will be repeated for \nnloops. ',...
                        ' this is the final close time/destination and close \n1',....
                        ' and close 2 time are the first and second smaller \nsteps',...
                        ' before this triggers to ensure animal has warning of \nclose',...
                        ' Generally, 1.5 is 90 deg, < 1.5 is 0 deg, > 1.5 is 180 deg']),...
        'label','ON time [ms]', 'position', [x y w 30]);
        % Close wave 1 on time
        NumeditParam(obj, 'l_close_1_on_time_ms', 1.2, x, y,'labelfraction',0.5,...
        'TooltipString', sprintf(['\non time of first servo wave that will \nslightly ',...
                        'move the to indicate close is happening']),...
        'label', 'close 1 on time [ms]', 'position', [x+x_offset y w 30]);         
        % Total off time (used for 1st, 2nd and 3rd (final) wave close)
        DispParam(obj, 'l_close_total_on_time_ms', 7.5, x, y, 'labelfraction', 0.7,...
        'TooltipString', sprintf(['\ngiven on time and n loops how \nlong ',...
                         'the wave is hi in ms']),...
        'label', 'total on time [ms]', 'position', [x+(2*x_offset) y w 30]);
        % Duration of 1 loop (on time + off time) for final close
        DispParam(obj, 'l_close_loop_duration_ms', 20, x, y, 'labelfraction', 0.7,...
        'TooltipString', sprintf(['\nthe length of a single loop as defined \nby ',...
                         'on time + off time. Multipled by n loops & converted \nto ',...
                         'seconds gets you the wave duration']),...
        'label', 'loop dur [ms]', 'position', [x+(3*x_offset) y w 30]); next_row(y,1.75);;;
        %%%---
        SubheaderParam(obj,'lab1', 'Parameters',x,y,'position', [x y (2*w)-10 30]);
        SubheaderParam(obj,'lab3', 'Summary', x, y, 'position', [x+(2*x_offset) y x_offset 30]);
        PushbuttonParam(obj, 'update_l_close_summary', x, y, 'position', [x+(3*x_offset) y w-10 30],...
            'label', 'update', 'TooltipString', 'Given parameters, update servo close summary info.');
        set_callback(update_l_close_summary, {mfilename, 'calculate_left_close_summary'});next_row (y,1.5)
                SubheaderParam(obj,'lab1', 'LEFT CLOSE- Trigger via  L or C poke OUT on Bpod Console',...
                x,y,'position', [x+30 y w*n_cols 30]);next_row(y,1.75);;;
        
        %%% LEFT OPEN VARIABLES %%%
        %%%---
        % Number of wave loops
        NumeditParam(obj, 'l_open_n_loops', 5, x, y,'labelfraction',0.5,...
        'TooltipString', sprintf(['\nNumber of loops of the wave (i.e. \nnumber ',...
                        'of pulses that will be sent to servo)']),...
        'label', 'N loops', 'position', [x y w 30]);
        % Duty cycle (high/low * 100)
        DispParam(obj, 'l_open_duty_cycle', 5.5, x, y, 'labelfraction', 0.7,...
        'TooltipString', sprintf(['\ngiven on, off time, the percent of time in \nloop ',...
                                  'spent with the wave hi/pulse on']),...
        'label', 'duty cycle [%]', 'position', [x+(2*x_offset) y w 30]);
        % Pulse rate (n highs/second )
        DispParam(obj, 'l_open_pulse_rate', 50, x, y, 'labelfraction', 0.7,...
        'TooltipString', sprintf(['\ngiven on and off time, how many pulses \nper ',...
                         'second (Hz). Servo expects btwn 20-200 Hz ']),...
        'label', 'pulse rate [Hz]', 'position', [x+(3*x_offset) y w 30]); next_row(y,1.75);;;
        %%%---
        % Off/lo time in single pulse (1 loop)
        NumeditParam(obj, 'l_open_off_time_ms', 18.9, x, y,'labelfraction',0.5,...
        'TooltipString', sprintf(['\noff time in miliseconds of a single TTL \npulse ',...
                        'in the servo wave that will be repeated for nloops']),...
        'label', 'OFF time [ms]', 'position', [x y w 30]);
        % Total off time
        DispParam(obj, 'l_open_total_off_time_ms', 94.5, x, y, 'labelfraction', 0.7,...
        'TooltipString', sprintf(['\ngiven off time and n loops how \nlong ',...
                         'the wave is low in ms']),...
        'label', 'total off time [ms]', 'position', [x+(2*x_offset) y w 30]);
        % Total duration of all loops (on time + off time) * nloops
        DispParam(obj, 'l_open_loops_duration_ms', 100, x, y, 'labelfraction', 0.7,...
        'TooltipString', sprintf(['\ngiven on, off and n loops, how long the \nservop ',...
                         'wave TTL signal will last in seconds']),...
        'label', 'loops dur [ms]', 'position', [x+(3*x_offset) y w 30]); next_row(y,1.75);;;
        %%%---
        % On/hi time in a single loop
        NumeditParam(obj,'l_open_on_time_ms',1.1,x, y, 'labelfraction',0.5,...
        'TooltipString', sprintf(['\non time in miliseconds of a single TTL \npulse ',...
                        'in the servo wave that will be repeated for \nnloops. '...,
                        ' Generally, 1.5 is 90 deg, < 1.5 is 0 deg, > 1.5 is 180 deg']),...
        'label','ON time [ms]', 'position', [x y w 30]);
        % Total off time
        DispParam(obj, 'l_open_total_on_time_ms', 5.5, x, y, 'labelfraction', 0.7,...
        'TooltipString', sprintf(['\ngiven on time and n loops how \nlong ',...
                         'the wave is hi in ms']),...
        'label', 'total on time [ms]', 'position', [x+(2*x_offset) y w 30]);
        % Duration of 1 loop (on time + off time)
        DispParam(obj, 'l_open_loop_duration_ms', 20, x, y, 'labelfraction', 0.7,...
        'TooltipString', sprintf(['\nthe length of a single loop as defined \nby ',...
                         'on time + off time. Multipled by n loops & converted \nto ',...
                         'seconds gets you the wave duration']),...
        'label', 'loop dur [ms]', 'position', [x+(3*x_offset) y w 30]); next_row(y,1.75);;;
        %%%---
        SubheaderParam(obj,'lab1', 'Parameters',x,y,'position', [x y (2*w)-10 30]);
        SubheaderParam(obj,'lab3', 'Summary', x, y, 'position', [x+(2*x_offset) y x_offset 30]);
        PushbuttonParam(obj, 'update_l_open_summary', x, y, 'position', [x+(3*x_offset) y w-10 30],...
            'label', 'update', 'TooltipString', 'Given parameters, update servo open summary info.');
        set_callback(update_l_open_summary, {mfilename, 'calculate_left_open_summary'});next_row (y,1.5)
                SubheaderParam(obj,'lab1', 'LEFT OPEN- Trigger via L or C poke IN on Bpod Console',...
            x,y,'position', [x+30 y w*n_cols 30]);

        % GUI is made, time to construct a trial
        ServoTester('prepare_next_trial');

    %---------------------------------------------------------------%
    %    PREAPARE NEXT TRIAL                                        %
    %---------------------------------------------------------------%
    case 'prepare_next_trial'
        
        %%% define DIO lines
        % if on a rig with BNCs & correct firmware on bpod (ask
        % chuck) then you can use them, otherwise just send the waves 
        % to the LEDs so you can test the protocol
        bnc_port_not_setup = isnan(bSettings('get', 'DIOLINES', 'bnc5'));
         
        if bnc_port_not_setup
            l_door    = bSettings('get', 'DIOLINES', 'left1led');
            r_door   = bSettings('get', 'DIOLINES', 'right1led');
        else
            l_door    = bSettings('get', 'DIOLINES', 'bnc5');
            r_door   = bSettings('get', 'DIOLINES', 'bnc6');
        end
        
 
        sma = StateMachineAssembler('full_trial_structure','use_happenings',1);
        
        %%%%%%%%%%%%%%%%%%%%%%%%%%
        %%%       WAVES        %%%
        %%%%%%%%%%%%%%%%%%%%%%%%%%
        %%%%%    RIGHT DOOR   %%%%%
        %%%        OPEN        %%%
        sma = add_scheduled_wave(sma, 'name', 'r_open_door_wave',...
                                      'preamble', (value(r_open_off_time_ms) / 1000),...
                                      'sustain',  (value(r_open_on_time_ms) / 1000),...
                                      'loop',     value(r_open_n_loops),...
                                      'DOut',     r_door);
        
        % add wave hi/lo happening to allow for use as state output action
        ro_wn = get_wavenumber(sma, 'r_open_door_wave');
        sma = add_happening_spec(sma, struct(...
                                    'name', {'r_open_door_wave_hi', 'r_open_door_wave_lo'},...
                                    'detectorFunctionName', {'wave_high', 'wave_low'},...
                                    'inputNumber', {ro_wn, ro_wn}));
        
        %%%        CLOSE       %%%
        sma = add_scheduled_wave(sma, 'name', 'r_close_door_wave_1',...
                                      'preamble', value(r_close_off_time_ms) / 1000,...
                                      'sustain',  value(r_close_1_on_time_ms) / 1000,... % only change on time
                                      'loop',     value(r_close_n_loops),...
                                      'DOut',     r_door);
        sma = add_scheduled_wave(sma, 'name', 'r_close_door_wave_2',...
                                      'preamble', (value(r_close_off_time_ms) / 1000),...
                                      'sustain',  (value(r_close_2_on_time_ms) / 1000),... % only change on time
                                      'loop',     value(r_close_n_loops),...
                                      'DOut',     r_door);
        sma = add_scheduled_wave(sma, 'name', 'r_close_door_wave_3',...
                                      'preamble', (value(r_close_off_time_ms) / 1000),...
                                      'sustain',  (value(r_close_on_time_ms) / 1000),... % use the final setting
                                      'loop',     value(r_close_n_loops),...
                                      'DOut',     r_door);

        rc_wn = get_wavenumber(sma, 'r_close_door_wave_3');
        sma = add_happening_spec(sma, struct(...
                                    'name', {'r_close_door_wave_3_hi', 'r_close_door_wave_3_lo'},...
                                    'detectorFunctionName', {'wave_high', 'wave_low'},...
                                    'inputNumber', {rc_wn, rc_wn}));
        %%%%%    LEFT DOOR   %%%%%
        %%%        OPEN        %%%
        sma = add_scheduled_wave(sma, 'name', 'l_open_door_wave',...
                                      'preamble', (value(l_open_off_time_ms) / 1000),...
                                      'sustain',  (value(l_open_on_time_ms) / 1000),...
                                      'loop',     value(l_open_n_loops),...
                                      'DOut',     l_door);
        
        % add wave hi/lo happening to allow for use as state output action
        lo_wn = get_wavenumber(sma, 'l_open_door_wave');
        sma = add_happening_spec(sma, struct(...
                                    'name', {'l_open_door_wave_hi', 'l_open_door_wave_lo'},...
                                    'detectorFunctionName', {'wave_high', 'wave_low'},...
                                    'inputNumber', {lo_wn, lo_wn}));
        
        %%%        CLOSE       %%%
        sma = add_scheduled_wave(sma, 'name', 'l_close_door_wave_1',...
                                      'preamble', value(l_close_off_time_ms) / 1000,...
                                      'sustain',  value(l_close_1_on_time_ms) / 1000,... % only change on time
                                      'loop',     value(l_close_n_loops),...
                                      'DOut',     l_door);
        sma = add_scheduled_wave(sma, 'name', 'l_close_door_wave_2',...
                                      'preamble', value(l_close_off_time_ms) / 1000,...
                                      'sustain',  value(l_close_2_on_time_ms) / 1000,... % only change on time
                                      'loop',     value(l_close_n_loops),...
                                      'DOut',     l_door);
        sma = add_scheduled_wave(sma, 'name', 'l_close_door_wave_3',...
                                      'preamble', value(l_close_off_time_ms) / 1000,...
                                      'sustain',  value(l_close_on_time_ms) / 1000,... % use the final setting
                                      'loop',     value(l_close_n_loops),...
                                      'DOut',     l_door);

        lc_wn = get_wavenumber(sma, 'l_close_door_wave_3');
        sma = add_happening_spec(sma, struct(...
                                    'name', {'l_close_door_wave_3_hi', 'l_close_door_wave_3_lo'},...
                                    'detectorFunctionName', {'wave_high', 'wave_low'},...
                                    'inputNumber', {lc_wn, lc_wn}));
        

        %%%%%%%%%%%%%%%%%%%%%%%%%%
        %%%       STATES       %%%
        %%%%%%%%%%%%%%%%%%%%%%%%%%
        %! Requires door to be opened and then closed to complete trial via Lin/out

        % wait for door(s) open
        sma = add_state(sma, 'name', 'wait_for_door_open',...
                             'input_to_statechange', {'Lin', 'l_open_door';...
                                                      'Rin', 'r_open_door';...
                                                      'Cin', 'rl_open_door'});
        
        %%% OPEN DOOR(S)                                              
        % LEFT                       
        sma = add_state(sma, 'name', 'l_open_door',...
                             'output_actions', {'SchedWaveTrig', 'l_open_door_wave'},...
                             'input_to_statechange', {'l_open_door_wave_hi', 'wait_for_l_close_door'});
        % RIGHT
        sma = add_state(sma, 'name', 'r_open_door',...
                             'output_actions', {'SchedWaveTrig', 'r_open_door_wave'},...
                             'input_to_statechange', {'r_open_door_wave_hi', 'wait_for_r_close_door'});
        %BOTH
        sma = add_state(sma, 'name', 'rl_open_door',...
                             'output_actions', {'SchedWaveTrig', 'r_open_door_wave + l_open_door_wave'},...
                             'input_to_statechange', {'l_open_door_wave_hi', 'wait_for_rl_close_door'});
        
        %%% WAIT FOR DOOR(S) CLOSE
        % LEFT
        sma = add_state(sma, 'name', 'wait_for_l_close_door',...
                             'input_to_statechange', {'Lout', 'l_close_door_1'});   
        % RIGHT
        sma = add_state(sma, 'name', 'wait_for_r_close_door',...
                             'input_to_statechange', {'Rout', 'r_close_door_1'});
        % BOTH
        sma = add_state(sma, 'name', 'wait_for_rl_close_door',...
                             'input_to_statechange', {'Cout', 'rl_close_door_1'});

        %%% CLOSE DOOR(S) %%%%
        % done in three steps with each step moving progressively closer to 
        % the final close position with a short pause to ensure mouse safety
        % LEFT %
        sma = add_state(sma, 'name', 'l_close_door_1',...
                             'self_timer', value(l_close_pause_time_s),...
                             'output_actions', {'SchedWaveTrig', 'l_close_door_wave_1'},...
                             'input_to_statechange', {'Tup', 'l_close_door_2'});
        sma = add_state(sma, 'name', 'l_close_door_2',...
                             'self_timer', value(l_close_pause_time_s),...
                             'output_actions', {'SchedWaveTrig', 'l_close_door_wave_2'},...
                             'input_to_statechange', {'Tup', 'l_close_door_3'});                     
        sma = add_state(sma, 'name', 'l_close_door_3',...
                            'output_actions', {'SchedWaveTrig', 'l_close_door_wave_3'},...
                            'input_to_statechange', {'l_close_door_wave_3_hi', 'final_state'});                            
        % RIGHT
        sma = add_state(sma, 'name', 'r_close_door_1',...
                             'self_timer', value(r_close_pause_time_s),...
                             'output_actions', {'SchedWaveTrig', 'r_close_door_wave_1'},...
                             'input_to_statechange', {'Tup', 'r_close_door_2'});
        sma = add_state(sma, 'name', 'r_close_door_2',...
                             'self_timer', value(r_close_pause_time_s),...
                             'output_actions', {'SchedWaveTrig', 'r_close_door_wave_2'},...
                             'input_to_statechange', {'Tup', 'r_close_door_3'});                     
        sma = add_state(sma, 'name', 'r_close_door_3',...
                            'output_actions', {'SchedWaveTrig', 'r_close_door_wave_3'},...
                            'input_to_statechange', {'r_close_door_wave_3_hi', 'final_state'});            
        % BOTH
        sma = add_state(sma, 'name', 'rl_close_door_1',...
                             'self_timer', value(r_close_pause_time_s),...
                             'output_actions', {'SchedWaveTrig', 'r_close_door_wave_1 + l_close_door_wave_1'},...
                             'input_to_statechange', {'Tup', 'rl_close_door_2'});
        sma = add_state(sma, 'name', 'rl_close_door_2',...
                             'self_timer', value(r_close_pause_time_s),...
                             'output_actions', {'SchedWaveTrig', 'r_close_door_wave_2 + l_close_door_wave_2'},...
                             'input_to_statechange', {'Tup', 'rl_close_door_3'});                     
        sma = add_state(sma, 'name', 'rl_close_door_3',...
                            'output_actions', {'SchedWaveTrig', 'r_close_door_wave_3 + l_close_door_wave_3'},...
                            'input_to_statechange', {'l_close_door_wave_3_hi', 'final_state'});             
        % TRIAL COMPLETE
        sma = add_state(sma, 'name', 'final_state',... 
                             'self_timer', 1,... 
                             'input_to_statechange', {'Tup', 'check_next_trial_ready'});

        dispatcher('send_assembler', sma, 'final_state');

    %---------------------------------------------------------------
    %          CALCULATE OPEN SUMMARY
    %---------------------------------------------------------------
    
    case 'calculate_left_open_summary'
        
        disp('updating left servo open wave summary!')
        l_open_total_on_time_ms.value  = value(l_open_on_time_ms) * value(l_open_n_loops);
        l_open_total_off_time_ms.value  = value(l_open_off_time_ms) * value(l_open_n_loops);
        
        l_open_loop_duration_ms.value  = value(l_open_on_time_ms) + value(l_open_off_time_ms);
        l_open_loops_duration_ms.value = value(l_open_loop_duration_ms) * value(l_open_n_loops);
        
        l_open_duty_cycle.value        = (value(l_open_on_time_ms) / value(l_open_loop_duration_ms)) * 100;
        l_open_pulse_rate.value        = 1000 / value(l_open_loop_duration_ms);
    
    case 'calculate_right_open_summary'

        disp('updating right servo open wave summary!')
        r_open_total_on_time_ms.value  = value(r_open_on_time_ms) * value(r_open_n_loops);
        r_open_total_off_time_ms.value  = value(r_open_off_time_ms) * value(r_open_n_loops);
        
        r_open_loop_duration_ms.value  = value(r_open_on_time_ms) + value(r_open_off_time_ms);
        r_open_loops_duration_ms.value = value(r_open_loop_duration_ms) * value(r_open_n_loops);
        
        r_open_duty_cycle.value        = (value(r_open_on_time_ms) / value(r_open_loop_duration_ms)) * 100;
        r_open_pulse_rate.value        = 1000 / value(r_open_loop_duration_ms);
        
    %---------------------------------------------------------------
    %          CALCULATE CLOSE SUMMARY
    %---------------------------------------------------------------
    
    case 'calculate_left_close_summary'
        
        disp('updating left servo close wave summary!')
        l_close_total_on_time_ms.value  = value(l_close_on_time_ms) * value(l_close_n_loops);
        l_close_total_off_time_ms.value  = value(l_close_off_time_ms) * value(l_close_n_loops);
        
        l_close_loop_duration_ms.value  = value(l_close_on_time_ms) + value(l_close_off_time_ms);
        l_close_loops_duration_ms.value = value(l_close_loop_duration_ms) * value(l_close_n_loops);
        
        l_close_duty_cycle.value        = (value(l_close_on_time_ms) / value(l_close_loop_duration_ms)) * 100;
        l_close_pulse_rate.value        = 1000 / value(l_close_loop_duration_ms);
    
    case 'calculate_right_close_summary'
        
        disp('updating right servo close wave summary!')
        r_close_total_on_time_ms.value  = value(r_close_on_time_ms) * value(r_close_n_loops);
        r_close_total_off_time_ms.value  = value(r_close_off_time_ms) * value(r_close_n_loops);
        
        r_close_loop_duration_ms.value  = value(r_close_on_time_ms) + value(r_close_off_time_ms);
        r_close_loops_duration_ms.value = value(r_close_loop_duration_ms) * value(r_close_n_loops);
        
        r_close_duty_cycle.value        = (value(r_close_on_time_ms) / value(r_close_loop_duration_ms)) * 100;
        r_close_pulse_rate.value        = 1000 / value(r_close_loop_duration_ms);
        
    %---------------------------------------------------------------
    %          UPDATE
    %---------------------------------------------------------------
    case 'update'    
        % writing this in to keep dispatcher happy so it doesn't
        % produce a warning every update & saving out some variables
        % that are useful if paused in debug here
        peh = parsed_events_history;
        pe  = parsed_events; %#ok<NASGU>
        
    %---------------------------------------------------------------
    %          CASE TRIAL_COMPLETED
    %---------------------------------------------------------------
    case 'trial_completed' 
        % writing this in to keep dispatcher happy so it doesn't
        % produce a warning every update
    %---------------------------------------------------------------
    %          CLOSE PROTOCOL
    %---------------------------------------------------------------
    case 'close'

        dispatcher('Stop');
    
        %Let's pause until we know dispatcher is done running
        set(value(stopping_complete_timer),'TimerFcn',[mfilename,'(''close_continued'');']);
        start(value(stopping_complete_timer));
        
    case 'close_continued'
    
        if value(stopping_process_completed)
            stop(value(stopping_complete_timer)); %Stop looping.
            %dispatcher('set_protocol','');
        
        if exist('myfig', 'var') && isa(myfig, 'SoloParamHandle') && ishandle(value(myfig)), %#ok<NODEF>
            delete(value(myfig));
        end;
        delete_sphandle('owner', ['^@' class(obj) '$']);
        dispatcher('set_protocol','');
        end
    otherwise,
    warning('Unknown action! "%s"\n', action); %#ok<WNTAG>
end;

return;